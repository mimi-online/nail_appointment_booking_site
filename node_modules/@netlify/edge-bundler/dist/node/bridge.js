import { promises as fs } from 'fs';
import path from 'path';
import process from 'process';
import { execa } from 'execa';
import pathKey from 'path-key';
import semver from 'semver';
import { download } from './downloader.js';
import { getPathInHome } from './home_path.js';
import { getLogger } from './logger.js';
import { getBinaryExtension } from './platform.js';
const DENO_VERSION_FILE = 'version.txt';
// When updating DENO_VERSION_RANGE, ensure that the deno version
// on the netlify/buildbot build image satisfies this range!
// https://github.com/netlify/buildbot/blob/f9c03c9dcb091d6570e9d0778381560d469e78ad/build-image/noble/Dockerfile#L410
export const DENO_VERSION_RANGE = '^2.4.2';
export class DenoBridge {
    cacheDirectory;
    currentDownload;
    debug;
    denoDir;
    logger;
    onAfterDownload;
    onBeforeDownload;
    useGlobal;
    versionRange;
    constructor(options) {
        this.cacheDirectory = options.cacheDirectory ?? getPathInHome('deno-cli');
        this.debug = options.debug ?? false;
        this.denoDir = options.denoDir;
        this.logger = options.logger ?? getLogger(undefined, undefined, options.debug);
        this.onAfterDownload = options.onAfterDownload;
        this.onBeforeDownload = options.onBeforeDownload;
        this.useGlobal = options.useGlobal ?? true;
        this.versionRange = options.versionRange ?? DENO_VERSION_RANGE;
    }
    async downloadBinary() {
        await this.onBeforeDownload?.();
        await this.ensureCacheDirectory();
        this.logger.system(`Downloading Deno CLI to ${this.cacheDirectory}`);
        const binaryPath = await download(this.cacheDirectory, this.versionRange, this.logger);
        const downloadedVersion = await this.getBinaryVersion(binaryPath);
        // We should never get here, because it means that `DENO_VERSION_RANGE` is
        // a malformed semver range. If this does happen, let's throw an error so
        // that the tests catch it.
        if (downloadedVersion === undefined) {
            const error = new Error('There was a problem setting up the Edge Functions environment. To try a manual installation, visit https://ntl.fyi/install-deno.');
            await this.onAfterDownload?.(error);
            this.logger.system('Could not run downloaded Deno CLI', error);
            throw error;
        }
        await this.writeVersionFile(downloadedVersion);
        await this.onAfterDownload?.();
        return binaryPath;
    }
    async getBinaryVersion(binaryPath) {
        try {
            const { stdout } = await execa(binaryPath, ['--version']);
            const version = stdout.match(/^deno ([\d.]+)/);
            if (!version) {
                this.logger.system(`getBinaryVersion no version found. binaryPath ${binaryPath}`);
                return;
            }
            return version[1];
        }
        catch (error) {
            this.logger.system('getBinaryVersion failed', error);
        }
    }
    async getCachedBinary() {
        const versionFilePath = path.join(this.cacheDirectory, DENO_VERSION_FILE);
        let cachedVersion;
        try {
            cachedVersion = await fs.readFile(versionFilePath, 'utf8');
        }
        catch (error) {
            this.logger.system('Error getting cached binary', error);
            return;
        }
        if (!semver.satisfies(cachedVersion, this.versionRange)) {
            this.logger.system(`semver not satisfied. cachedVersion: ${cachedVersion}, versionRange: ${this.versionRange}`);
            return;
        }
        const binaryName = `deno${getBinaryExtension()}`;
        return path.join(this.cacheDirectory, binaryName);
    }
    async getGlobalBinary() {
        if (!this.useGlobal) {
            return;
        }
        const globalBinaryName = 'deno';
        const globalVersion = await this.getBinaryVersion(globalBinaryName);
        if (globalVersion === undefined || !semver.satisfies(globalVersion, this.versionRange)) {
            this.logger.system(`No globalVersion or semver not satisfied. globalVersion: ${globalVersion}, versionRange: ${this.versionRange}`);
            return;
        }
        return globalBinaryName;
    }
    getRemoteBinary() {
        if (this.currentDownload === undefined) {
            this.currentDownload = this.downloadBinary();
        }
        return this.currentDownload;
    }
    static runWithBinary(binaryPath, args, { options, pipeOutput, stderr, stdout, }) {
        const runDeno = execa(binaryPath, args, options);
        if (stderr) {
            runDeno.stderr?.pipe(stderr);
        }
        else if (pipeOutput) {
            runDeno.stderr?.pipe(process.stderr);
        }
        if (stdout) {
            runDeno.stdout?.pipe(stdout);
        }
        else if (pipeOutput) {
            runDeno.stdout?.pipe(process.stdout);
        }
        return runDeno;
    }
    async writeVersionFile(version) {
        await this.ensureCacheDirectory();
        const versionFilePath = path.join(this.cacheDirectory, DENO_VERSION_FILE);
        await fs.writeFile(versionFilePath, version);
    }
    async ensureCacheDirectory() {
        await fs.mkdir(this.cacheDirectory, { recursive: true });
    }
    async getBinaryPath(options) {
        const globalPath = await this.getGlobalBinary();
        if (globalPath !== undefined) {
            if (!options?.silent) {
                this.logger.system('Using global installation of Deno CLI');
            }
            return { global: true, path: globalPath };
        }
        const cachedPath = await this.getCachedBinary();
        if (cachedPath !== undefined) {
            if (!options?.silent) {
                this.logger.system('Using cached Deno CLI from', cachedPath);
            }
            return { global: false, path: cachedPath };
        }
        const downloadedPath = await this.getRemoteBinary();
        return { global: false, path: downloadedPath };
    }
    getEnvironmentVariables(inputEnv = {}) {
        const env = { ...inputEnv };
        if (this.denoDir !== undefined) {
            env.DENO_DIR = this.denoDir;
        }
        // Ensure PATH is always set as otherwise we are not able to find the global deno binary
        env[pathKey()] = inputEnv[pathKey({ env: inputEnv })] || process.env[pathKey()];
        return env;
    }
    // Runs the Deno CLI in the background and returns a reference to the child
    // process, awaiting its execution.
    async run(args, { cwd, env: inputEnv, extendEnv = true, rejectOnExitCode = true, stderr, stdout } = {}) {
        const { path: binaryPath } = await this.getBinaryPath();
        const env = this.getEnvironmentVariables(inputEnv);
        const options = { cwd, env, extendEnv, reject: rejectOnExitCode };
        return DenoBridge.runWithBinary(binaryPath, args, { options, stderr, stdout });
    }
    // Runs the Deno CLI in the background, assigning a reference of the child
    // process to a `ps` property in the `ref` argument, if one is supplied.
    async runInBackground(args, ref, { env: inputEnv, extendEnv = true, pipeOutput, stderr, stdout } = {}) {
        const { path: binaryPath } = await this.getBinaryPath();
        const env = this.getEnvironmentVariables(inputEnv);
        const options = { env, extendEnv };
        const ps = DenoBridge.runWithBinary(binaryPath, args, { options, pipeOutput, stderr, stdout });
        if (ref !== undefined) {
            ref.ps = ps;
        }
    }
}
